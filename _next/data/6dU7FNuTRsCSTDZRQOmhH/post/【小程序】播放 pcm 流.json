{"pageProps":{"post":{"id":26,"title":"【小程序】播放 pcm 流","created_at":"2025-01-01T17:32:02Z","updated_at":"2025-01-21T07:35:02Z","content":"### 实时播放 pcm 流\n\n```javascript\nexport class PCMPlayer {\n  constructor(option) {\n    this.init(option);\n  }\n\n  init(option) {\n    const defaultOption = {\n      inputCodec: 'Int16', // 传入的数据是采用多少位编码，默认16位\n      channels: 1, // 声道数\n      sampleRate: 8000, // 采样率 单位Hz\n      flushTime: 1000, // 缓存时间 单位 ms\n      fftSize: 2048 // analyserNode fftSize\n    };\n\n    this.option = Object.assign({}, defaultOption, option); // 实例最终配置参数\n    this.samples = new Float32Array(); // 样本存放区域\n    this.interval = setInterval(this.flush.bind(this), this.option.flushTime);\n    this.convertValue = this.getConvertValue();\n    this.typedArray = this.getTypedArray();\n    this.initAudioContext();\n    this.bindAudioContextEvent();\n  }\n\n  getConvertValue() {\n    // 根据传入的目标编码位数\n    // 选定转换数据所需要的基本值\n    const inputCodecs = {\n      'Int8': 128,\n      'Int16': 32768,\n      'Int32': 2147483648,\n      'Float32': 1\n    };\n    if (!inputCodecs[this.option.inputCodec]) throw new Error('wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32');\n    return inputCodecs[this.option.inputCodec];\n  }\n\n  getTypedArray() {\n    // 根据传入的目标编码位数\n    // 选定前端的所需要的保存的二进制数据格式\n    // 完整TypedArray请看文档\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\n    const typedArrays = {\n      'Int8': Int8Array,\n      'Int16': Int16Array,\n      'Int32': Int32Array,\n      'Float32': Float32Array\n    };\n    if (!typedArrays[this.option.inputCodec]) throw new Error('wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32');\n    return typedArrays[this.option.inputCodec];\n  }\n\n  initAudioContext() {\n    // 初始化音频上下文的东西\n    this.audioCtx = createWebAudioContext();\n    // 控制音量的 GainNode\n    // https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createGain\n    this.gainNode = this.audioCtx.createGain();\n    this.gainNode.gain.value = 1;\n    this.gainNode.connect(this.audioCtx.destination);\n    this.startTime = this.audioCtx.currentTime;\n    this.analyserNode = this.audioCtx.createAnalyser();\n    this.analyserNode.fftSize = this.option.fftSize;\n  }\n\n  static isTypedArray(data) {\n    // 检测输入的数据是否为 TypedArray 类型或 ArrayBuffer 类型\n    return (data.byteLength && data.buffer && data.buffer instanceof ArrayBuffer) || data instanceof ArrayBuffer;\n  }\n\n  isSupported(data) {\n    // 数据类型是否支持\n    // 目前支持 ArrayBuffer 或者 TypedArray\n    if (!PCMPlayer.isTypedArray(data)) throw new Error('请传入ArrayBuffer或者任意TypedArray');\n    return true;\n  }\n\n  feed(data) {\n    this.isSupported(data);\n\n    // 获取格式化后的buffer\n    data = this.getFormattedValue(data);\n    // 开始拷贝buffer数据\n    // 新建一个Float32Array的空间\n    const tmp = new Float32Array(this.samples.length + data.length);\n    // console.log(data, this.samples, this.samples.length)\n    // 复制当前的实例的buffer值（历史buff)\n    // 从头（0）开始复制\n    tmp.set(this.samples, 0);\n    // 复制传入的新数据\n    // 从历史buff位置开始\n    tmp.set(data, this.samples.length);\n    // 将新的完整buff数据赋值给samples\n    // interval定时器也会从samples里面播放数据\n    this.samples = tmp;\n    // console.log('this.samples', this.samples)\n  }\n\n  getFormattedValue(data) {\n    if (data instanceof ArrayBuffer) {\n      data = new this.typedArray(data);\n    } else {\n      data = new this.typedArray(data.buffer);\n    }\n\n    let float32 = new Float32Array(data.length);\n\n    for (let i = 0; i < data.length; i++) {\n      // buffer 缓冲区的数据，需要是IEEE754 里32位的线性PCM，范围从-1到+1\n      // 所以对数据进行除法\n      // 除以对应的位数范围，得到-1到+1的数据\n      // float32[i] = data[i] / 0x8000;\n      float32[i] = data[i] / this.convertValue;\n    }\n    return float32;\n  }\n\n  volume(volume) {\n    this.gainNode.gain.value = volume;\n  }\n\n  destroy() {\n    if (this.interval) {\n      clearInterval(this.interval);\n    }\n    this.samples = null;\n    this.audioCtx.close().then();\n    this.audioCtx = null;\n  }\n\n  flush() {\n    if (!this.samples.length) return;\n    const self = this;\n    const bufferSource = this.audioCtx.createBufferSource();\n    if (typeof this.option.onended === 'function') {\n      bufferSource.onended = function (event) {\n        self.option.onended(this, event);\n      };\n    }\n    const length = this.samples.length / this.option.channels;\n    const audioBuffer = this.audioCtx.createBuffer(this.option.channels, length, this.option.sampleRate);\n\n    for (let channel = 0; channel < this.option.channels; channel++) {\n      const audioData = audioBuffer.getChannelData(channel);\n      let offset = channel;\n      let decrement = 50;\n      for (let i = 0; i < length; i++) {\n        audioData[i] = this.samples[offset];\n        /* fadein */\n        if (i < 50) {\n          audioData[i] = (audioData[i] * i) / 50;\n        }\n        /* fadeout*/\n        if (i >= (length - 51)) {\n          audioData[i] = (audioData[i] * decrement--) / 50;\n        }\n        offset += this.option.channels;\n      }\n    }\n\n    if (this.startTime < this.audioCtx.currentTime) {\n      this.startTime = this.audioCtx.currentTime;\n    }\n    // console.log('start vs current ' + this.startTime + ' vs ' + this.audioCtx.currentTime + ' duration: ' + audioBuffer.duration);\n    // console.log('start', this.startTime);\n    // console.log('duration', audioBuffer.duration);\n    bufferSource.buffer = audioBuffer;\n    bufferSource.connect(this.gainNode);\n    bufferSource.connect(this.analyserNode); // bufferSource连接到analyser\n    bufferSource.start(this.startTime);\n    this.option?.onstart(audioBuffer.duration);\n    this.startTime += audioBuffer.duration;\n    this.samples = new Float32Array();\n  }\n\n  async pause() {\n    await this.audioCtx.suspend();\n  }\n\n  async continue() {\n    await this.audioCtx.resume();\n  }\n\n  bindAudioContextEvent() {\n    const self = this;\n    if (typeof self.option.onstatechange === 'function') {\n      this.audioCtx.onstatechange = function (event) {\n        self.audioCtx && self.option.onstatechange(this, event, self.audioCtx.state);\n      };\n    }\n  }\n\n}\n\nexport default PCMPlayer;\n```","author":"z0ffy","reactions":{"url":"https://api.github.com/repos/z0ffy/z0ffy.github.io/issues/26/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"labels":["published","前端"]}},"__N_SSG":true}